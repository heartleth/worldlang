{
    "name": "Common Lisp",
    "ext": "lisp",
    "h_ext": "lisp",

    "line_end": "",

    "ident": "{{name}}",
    "true": "T",
    "false": "NIL",

    "bracket": {
        "block_open": "(sg ",
        "block_close": ")",

        "value_open": "(sg ",
        "value_close": ")",

        "dotarray_open": "(vector ",
        "dotarray_close": ")",

        "list_open": "(list ",
        "list_close": ")"
    },
    "operator": {
        "commas" : " ",

        "pointer" : "(&({{exp}}))",
        "de_pointer" : "(*({{exp}}))",

        "await" : "(({{exp}}).get())",
        "async" : "async({{exp}})",

        "tenary": "(({{condition}})?({{l}}):({{r}}))",
        "assign" : "(setf {{l}} {{r}})",

        "plus" : "(+ {{l}} {{r}})",
        "minus" : "(- {{l}} {{r}})",
        
        "bitor" : "(logior {{l}} {{r}})",
        "or" : "({{l}} || {{r}})",
        "bitand" : "(logand {{l}} {{r}})",
        "and" : "({{l}} && {{r}})",

        "eq" : "(= {{l}} {{r}})",
        "neq" : "(/= {{l}} {{r}})",
        
        "pair" : "std::pair<std::string, std::string>({{l}}, {{r}})",
        
        "property" : "{{object}}.{{name}}",
        "context" : "{{context}}::{{member}}",
        "index" : "(svref {{exp}} {{at}})",

        "else" : "({{operator}} {{l}} {{r}})"
    },
    "blocks": {
        "if": "(if ({{exp}}) then ( {{block}} ))",
        "else_if": "else if ({{exp}}) { {{block}} }",
        "else": "else { {{block}} }",

        "while": "while ({{exp}}) { {{block}} }",
        "repeat": "for (int {{var}} = 0; {{var}}<{{time}}; {{var}}++) { {{block}} }",
        "foreach": "for ({{var}} : {{collection}}) { {{block}} }"
    },
    "calls": {
        "call": "({{method}} {{args}})",
        "method_call" : "{{call}}"
    },
    "types": {
        "deduce_type": "atom",
        "constant": "",
        "void_type": "null",
        "integer": "int"
    },

    "lambda_blocks": "(lambda ({{args}}) {{block}} )",
    "to_lambdas": "(lambda (&rest args) (eval `({{fucntion}} {{args}} ,@args)))",
    "lambdas": "(lambda ({{args}}) {{exp}})",

    "returns": "{{exp}}",

    "namespaces": "{{block}}",

    "iter_vars": "{{name}}",
    "arg_vars": "{{name}}",

    "header_guards": "(defun sg (s) s)\n{{contents}}\n",

    "funcs": {
        "functions": "(defun {{name}}({{args}}) { {{block}} })",
        "constructor": "{{class}}({{args}}){ {{block}} }",
        "entry": "{{block}}"
    },
    "assigns": {
        "reference": {
            "const": "const {{type}}& {{name}} = {{ref}}",
            "make": "{{type}}& {{name}} = {{ref}}",
            "let": "{{type}}& {{name}} = {{ref}}",
            "instance": "{{type}}& {{name}} = {{ref}}"
        },
        "copy": {
            "const": "const {{type}} {{name}} = {{copy}}",
            "make": "{{type}}* {{name}} = new {{type}}({{copy}})",
            "let": "{{type}} {{name}} = {{copy}}",
            "instance": "{{type}} {{name}} = {{copy}}"
        },
        "construct": {
            "const": "const {{type}} {{name}}({{args}})",
            "make": "{{type}}* {{name}} = new {{type}}({{args}})",
            "let": "{{type}} {{name}}({{args}})",
            "instance": "{{type}} {{name}}({{args}})"
        }
    },
    "imports": {
        "import": "#include \"{{path}}.hpp\"\n",
        "stdlib": "#include \"worldlib.hpp\"\n",
        "library": "#include <{{path}}>\n",

        "targetstdlibpath": "worldlib.hpp",
        "stdlibpath": "../libs/worldlib.hpp"
    },
    "classes": {
        "inherit": "class {{name}} : {{super}} { {{block}} };",
        "class": "class {{name}}{ {{block}} };"
    },
    "access": {
        "protected": "protected:",
        "private": "private:",
        "public": "public:"
    }
}